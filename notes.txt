failed cursor component
import { useEffect, useRef } from "react";
import gsap from "gsap";
import { Observer } from "gsap/all";
import { useMediaQuery } from "react-responsive";

gsap.registerPlugin(Observer);

const size = 30; // default circle diameter in px
const PADDING = 50; // padding to add around the header when pinned
const PIN_BORDER_RADIUS = 10; // px border-radius for pinned rectangle

const Cursor = () => {
  const cursorRef = useRef(null);
  const velocityDataRef = useRef({ rotation: 0, scaleX: 1, scaleY: 1 });
  const lastMoveTimeRef = useRef(Date.now());
  const resetTimeoutRef = useRef(null);
  const inactivityIntervalRef = useRef(null);
  const isMouseDownRef = useRef(false);
  const isPinnedRef = useRef(false); // whether cursor is currently pinned to the header
  const pinnedTweenRef = useRef(null);
  const lastXRef = useRef(null);
  const lastYRef = useRef(null);
  const isTouchscreenSize = useMediaQuery({ maxWidth: "1024px" });

  useEffect(() => {
    if (isTouchscreenSize) return;
    const cursor = cursorRef.current;
    if (!cursor) return;

    // initial styling to ensure transform origin and fixed positioning
    gsap.set(cursor, {
      width: size,
      height: size,
      x: window.innerWidth / 2 - size / 2,
      y: window.innerHeight / 2 - size / 2,
      borderRadius: "50%",
      rotation: 0,
      scaleX: 1,
      scaleY: 1,
    });
    cursor.style.pointerEvents = "none"; // ensure it doesn't block interactions
    cursor.style.position = "fixed";
    cursor.style.top = "0";
    cursor.style.left = "0";

    let lastX = null;
    let lastY = null;
    let rafId = null;
    let pendingCheck = false;
    let isDragging = false;

    // Helper: set transform origin (strings like "0 0" or "50% 50%")
    const setTransformOrigin = (origin) => {
      cursor.style.transformOrigin = origin;
    };

    // Function to smoothly reset scales to 1
    const resetScalesToNormal = () => {
      if (isPinnedRef.current) return;
      gsap.to(cursor, {
        scaleX: 1,
        scaleY: 1,
        duration: 0.5,
        overwrite: "auto",
        ease: "power2.out",
      });
    };

    // Check inactivity
    const checkInactivity = () => {
      const now = Date.now();
      const timeSinceLastMove = now - lastMoveTimeRef.current;
      if (timeSinceLastMove > 150) {
        resetScalesToNormal();
      }
    };

    // Start inactivity checking
    inactivityIntervalRef.current = setInterval(checkInactivity, 500);

    // Observer for velocity-based animation
    const observer = Observer.create({
      type: "pointer",
      tolerance: 1,
      onMove: (self) => {
        // if pinned, ignore velocity transforms
        if (isPinnedRef.current) return;

        lastMoveTimeRef.current = Date.now();

        // Clear any pending reset
        if (resetTimeoutRef.current) {
          clearTimeout(resetTimeoutRef.current);
        }

        const deltaX = self.deltaX;
        const deltaY = self.deltaY;
        const velocityX = self.velocityX;
        const velocityY = self.velocityY;

        const velocity = Math.sqrt(
          velocityX * velocityX + velocityY * velocityY,
        );
        const normalizedVelocity = Math.min(Math.pow(velocity / 5000, 0.85), 1);

        // rotation based on movement direction
        let rotation = 0;
        if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
          rotation = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
        }

        const velocityFactor = normalizedVelocity;
        const scaleX = 1 + 0.55 * velocityFactor; // 1 to 1.55
        const scaleY = 1 - 0.55 * velocityFactor; // 1 to 0.45

        const finalScaleX = Math.max(1, scaleX);
        const finalScaleY = Math.min(1, Math.max(0.45, scaleY));

        velocityDataRef.current = {
          rotation,
          scaleX: finalScaleX,
          scaleY: finalScaleY,
        };

        if (normalizedVelocity > 0.05) {
          // fast rotation
          gsap.to(cursor, {
            rotation,
            duration: 0.001,
            ease: "none",
            overwrite: "auto",
          });

          // scale
          gsap.to(cursor, {
            scaleX: finalScaleX,
            scaleY: finalScaleY,
            duration: 0.2,
            ease: "power2.out",
            overwrite: "auto",
          });

          resetTimeoutRef.current = setTimeout(checkInactivity, 150);
        } else {
          resetScalesToNormal();
        }
      },
    });

    // --- Pin / Unpin logic ---

    // Get the github header element
    const githubHeaderEl = document.querySelector(".github-icon-link");

    // Helper to measure element and return expanded rect with padding
    const computePinnedRect = (element) => {
      const rect = element.getBoundingClientRect();
      return {
        left: rect.left - PADDING,
        top: rect.top - PADDING,
        width: rect.width + PADDING * 2,
        height: rect.height + PADDING * 2,
      };
    };

    // Pin: morph cursor into a pinned rectangle matching the header (with padding & border radius)
    const pinToElementRect = (element) => {
      if (!element) return;
      const target = computePinnedRect(element);

      // Stop any existing tweens
      gsap.killTweensOf(cursor);
      if (pinnedTweenRef.current) {
        pinnedTweenRef.current.kill();
        pinnedTweenRef.current = null;
      }

      // Set flag IMMEDIATELY to stop velocity observer
      isPinnedRef.current = true;

      // Get current transform-based position
      const currentTransform = gsap.getProperty(cursor, "x");
      const currentTransformY = gsap.getProperty(cursor, "y");

      // Clear transforms and set current position using left/top (seamless transition)
      gsap.set(cursor, {
        clearProps: "transform",
        left: currentTransform,
        top: currentTransformY,
      });

      // Now animate BOTH position AND morph together
      pinnedTweenRef.current = gsap.to(cursor, {
        duration: 0.45,
        ease: "power3.out",
        left: target.left,
        top: target.top,
        width: target.width,
        height: target.height,
        borderRadius: `${PIN_BORDER_RADIUS}px`,
        overwrite: "auto",
      });
    };
    // Unpin: morph back to circle and resume follow behavior
    const unpinToCircle = () => {
      // Stop tweens
      gsap.killTweensOf(cursor);
      if (pinnedTweenRef.current) {
        pinnedTweenRef.current.kill();
        pinnedTweenRef.current = null;
      }

      // Calculate target position for circle (under cursor)
      const targetX =
        lastXRef.current !== null ? lastXRef.current - size / 2 : 0;
      const targetY =
        lastYRef.current !== null ? lastYRef.current - size / 2 : 0;

      // Get current left/top position BEFORE clearing
      const currentLeft = gsap.getProperty(cursor, "left");
      const currentTop = gsap.getProperty(cursor, "top");

      // Switch from left/top to transform at CURRENT position (no jump)
      gsap.set(cursor, {
        clearProps: "left,top",
        x: currentLeft,
        y: currentTop,
        transformOrigin: "50% 50%",
      });

      // Animate position AND morph together
      pinnedTweenRef.current = gsap.to(cursor, {
        duration: 0.45,
        ease: "power3.out",
        x: targetX,
        y: targetY,
        width: size,
        height: size,
        borderRadius: "50%",
        scaleX: 1,
        scaleY: 1,
        overwrite: "auto",
        onComplete: () => {
          isPinnedRef.current = false;
        },
      });
    };
    // Header event handlers
    const onHeaderEnter = () => {
      // update last pointer coords in case needed
      // measure & pin
      pinToElementRect(githubHeaderEl);
    };

    const onHeaderLeave = () => {
      unpinToCircle();
    };

    const onHeaderFocusIn = () => {
      pinToElementRect(githubHeaderEl);
    };

    const onHeaderFocusOut = () => {
      unpinToCircle();
    };

    if (githubHeaderEl) {
      githubHeaderEl.addEventListener("pointerenter", onHeaderEnter, {
        passive: true,
      });
      githubHeaderEl.addEventListener("pointerleave", onHeaderLeave, {
        passive: true,
      });
      githubHeaderEl.addEventListener("focusin", onHeaderFocusIn);
      githubHeaderEl.addEventListener("focusout", onHeaderFocusOut);
    }

    // Update pinned rect on resize while pinned
    const onResize = () => {
      if (!isPinnedRef.current) return;
      // recompute and re-pin immediately (smooth update)
      if (githubHeaderEl) pinToElementRect(githubHeaderEl);
    };

    window.addEventListener("resize", onResize, { passive: true });

    // --- Existing movement / input handlers (respect pinned state) ---

    const getElementUnderPointer = (x, y) => {
      const els = document.elementsFromPoint(x, y);
      for (const element of els) {
        if (element === cursor || element.id === "cursor") continue;
        return element;
      }
      return null;
    };

    const checkElementUnderPointer = () => {
      pendingCheck = false;
      if (lastX === null || lastY === null) return;
      const element = getElementUnderPointer(lastX, lastY);
      // (we don't need to do anything here for this feature)
    };

    const scheduleCheck = () => {
      if (pendingCheck) return;
      pendingCheck = true;
      rafId = requestAnimationFrame(checkElementUnderPointer);
    };

    const onMouseMove = (e) => {
      lastX = e.clientX;
      lastY = e.clientY;
      lastXRef.current = lastX;
      lastYRef.current = lastY;
      lastMoveTimeRef.current = Date.now();

      // if pinned, do not follow pointer
      if (isPinnedRef.current) return;

      gsap.to(cursor, {
        x: e.clientX - size / 2,
        y: e.clientY - size / 2,
        duration: 0.7,
        ease: "back",
        overwrite: "auto",
      });

      if (!isDragging) {
        scheduleCheck();
      }
    };

    const onMouseDown = () => {
      isMouseDownRef.current = true;
      // do nothing if pinned
      if (isPinnedRef.current) return;

      gsap.to(cursor, {
        scale: 0.85,
        duration: 0.5,
        ease: "power2.out",
        overwrite: "auto",
      });
    };

    const onMouseUp = () => {
      isMouseDownRef.current = false;
      if (isPinnedRef.current) return;

      gsap.to(cursor, {
        scale: 1,
        duration: 0.5,
        ease: "back.out(3)",
        overwrite: "auto",
      });
    };

    const onCursorUpdate = (e) => {
      // custom external updates can still update lastX/lastY but should respect pinned state for follow
      if (e.detail?.x !== undefined && e.detail?.y !== undefined) {
        lastX = e.detail.x;
        lastY = e.detail.y;
        lastXRef.current = lastX;
        lastYRef.current = lastY;
        lastMoveTimeRef.current = Date.now();

        if (isPinnedRef.current) return;

        gsap.to(cursor, {
          x: e.detail.x - size / 2,
          y: e.detail.y - size / 2,
          duration: 0.1,
          ease: "power2.out",
          overwrite: "auto",
        });

        if (!isDragging) {
          scheduleCheck();
        }
      }
    };

    // Drag detection from your original logic
    const onDragStart = () => {
      isDragging = true;
    };

    const onDragEnd = () => {
      isDragging = false;
      scheduleCheck();
    };

    // global drag mousedown detection (keeps previous behavior)
    const mousedownForDrag = (e) => {
      const target = e.target;
      if (target.closest && target.closest(".dragger-wrapper")) {
        onDragStart();
      }
    };

    // add listeners
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseleave", resetScalesToNormal);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup", onMouseUp);
    window.addEventListener("cursorUpdate", onCursorUpdate);
    window.addEventListener("scroll", scheduleCheck, { passive: true });
    window.addEventListener("wheel", scheduleCheck, { passive: true });
    window.addEventListener("touchmove", scheduleCheck, { passive: true });
    document.addEventListener("mousedown", mousedownForDrag);
    document.addEventListener("mouseup", () => {
      if (isDragging) {
        onDragEnd();
      }
    });

    // cleanup on unmount
    return () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseleave", resetScalesToNormal);
      window.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mouseup", onMouseUp);
      window.removeEventListener("cursorUpdate", onCursorUpdate);
      window.removeEventListener("scroll", scheduleCheck);
      window.removeEventListener("wheel", scheduleCheck);
      window.removeEventListener("touchmove", scheduleCheck);
      document.removeEventListener("mousedown", mousedownForDrag);
      gsap.killTweensOf(cursor);
      if (pinnedTweenRef.current) {
        pinnedTweenRef.current.kill();
        pinnedTweenRef.current = null;
      }
      if (githubHeaderEl) {
        githubHeaderEl.removeEventListener("pointerenter", onHeaderEnter);
        githubHeaderEl.removeEventListener("pointerleave", onHeaderLeave);
        githubHeaderEl.removeEventListener("focusin", onHeaderFocusIn);
        githubHeaderEl.removeEventListener("focusout", onHeaderFocusOut);
      }
      window.removeEventListener("resize", onResize);
      if (inactivityIntervalRef.current)
        clearInterval(inactivityIntervalRef.current);
      if (resetTimeoutRef.current) clearTimeout(resetTimeoutRef.current);
      if (rafId) cancelAnimationFrame(rafId);
      observer.kill();
    };
  }, [isTouchscreenSize]);

  return (
    <div
      style={{
        width: size,
        height: size,
        zIndex: 99999999,
        transformOrigin: "center center",
      }}
      id="cursor"
      className="custom-cursor"
      ref={cursorRef}
    />
  );
};

export default Cursor;
